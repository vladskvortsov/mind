name: Deploy to ECR, ECS, RDS, ElasticCache
on: 
  workflow_dispatch:
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'project1/backend_redis/*'
  #     - 'project1/backend_rds/*'
jobs:
  deploy-rds-backend-to-ecr:
   runs-on: ubuntu-latest
   steps:
     - name: Checkout 
       uses: actions/checkout@v3
     - name: do something to the code
       run: echo "Changed code" > text.txt
     - id: ecr-publish
       name: Build image
       uses: bitovi/github-actions-ecr-publish@v0.1.0
       with:
         aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
         aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
         aws_default_region: ${{ secrets.AWS_REGION }}
         aws_ecr_repo_name: project1-backend
         image_tag: backend-rds
         working_directory: ./project1/backend_rds/
     - run: |
         echo "Image Created:  ${{ env.image }}"
         echo "Tag Created: ${{ env.tag }}"

  deploy-redis-backend-to-ecr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 
        uses: actions/checkout@v3
      - name: do something to the code
        run: echo "Changed code" > text.txt
      - id: ecr-publish
        name: Build image
        uses: bitovi/github-actions-ecr-publish@v0.1.0
        with:
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws_default_region: ${{ secrets.AWS_REGION }}
          aws_ecr_repo_name: project1-backend
          image_tag: backend-redis
          working_directory: ./project1/backend_redis/
      - run: |
          echo "Image Created:  ${{ env.image }}"
          echo "Tag Created: ${{ env.tag }}"







  # deploy-vpc:
  #   runs-on: ubuntu-latest
  #   outputs: 
  #     vpc_id: ${{ steps.create_vpc.outputs.vpc_id }}
  #     public_subnet_id: ${{ steps.create_subnets.outputs.public_subnet_id }}
  #     private_subnet_id: ${{ steps.create_subnets.outputs.private_subnet_id }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v3
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: ${{ secrets.AWS_REGION }}
          
  #     - name: Create VPC
  #       id: create_vpc
  #       run: |
  #         VPC_ID=$(aws ec2 create-vpc --cidr-block 10.0.0.0/16 --query 'Vpc.VpcId' --output text)
  #         aws ec2 modify-vpc-attribute --vpc-id $VPC_ID --enable-dns-support
  #         aws ec2 modify-vpc-attribute --vpc-id $VPC_ID --enable-dns-hostnames
  #         echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV
  #         echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT


  #     - name: Create Subnets
  #       id: create_subnets
  #       run: |
  #         PUBLIC_SUBNET_ID=$(aws ec2 create-subnet --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --cidr-block 10.0.1.0/24 --query 'Subnet.SubnetId' --output text)
  #         PRIVATE_SUBNET_ID=$(aws ec2 create-subnet --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --cidr-block 10.0.2.0/24 --query 'Subnet.SubnetId' --output text)
  #         echo "PUBLIC_SUBNET_ID=$PUBLIC_SUBNET_ID" >> $GITHUB_ENV
  #         echo "PRIVATE_SUBNET_ID=$PRIVATE_SUBNET_ID" >> $GITHUB_ENV
  #         echo "public_subnet_id=$PUBLIC_SUBNET_ID" >> $GITHUB_OUTPUT
  #         echo "private_subnet_id=$PRIVATE_SUBNET_ID" >> $GITHUB_OUTPUT

  #     - name: Create Internet Gateway and Route Table
  #       id: create_igw
  #       run: |
  #         IGW_ID=$(aws ec2 create-internet-gateway --query 'InternetGateway.InternetGatewayId' --output text)
  #         aws ec2 attach-internet-gateway --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --internet-gateway-id $IGW_ID
  #         RT_ID=$(aws ec2 create-route-table --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'RouteTable.RouteTableId' --output text)
  #         aws ec2 create-route --route-table-id $RT_ID --destination-cidr-block 0.0.0.0/0 --gateway-id $IGW_ID
  #         aws ec2 associate-route-table --subnet-id ${{ steps.create_subnets.outputs.public_subnet_id }} --route-table-id $RT_ID

  #     - name: Create Security Groups
  #       id: create_sg
  #       run: |
  #         ALB_SG_ID=$(aws ec2 create-security-group --group-name alb-sg --description "Security group for ALB" --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'GroupId' --output text)
  #         aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0
  #         aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
  #         ECS_SG_ID=$(aws ec2 create-security-group --group-name ecs-sg --description "Security group for ECS" --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'GroupId' --output text)
  #         aws ec2 authorize-security-group-ingress --group-id $ECS_SG_ID --protocol tcp --port 80 --source-group $ALB_SG_ID
  #         echo "ecs_sg_id=$ECS_SG_ID" >> $GITHUB_OUTPUT
  #         echo "alb_sg_id=$ALB_SG_ID" >> $GITHUB_OUTPUT

  #         echo "${{ steps.create_vpc.outputs.vpc_id }}"
  #         echo "${{ steps.create_subnets.outputs.public_subnet_id }}"
  #         echo "${{ steps.create_subnets.outputs.private_subnet_id }}"


  # deploy-ecs:
  #   runs-on: ubuntu-latest
  # # needs: deploy-rds-backend-to-ecr
  #   steps:
  #   - name: Create ECS Cluster
  #     run: |
  #       aws ecs create-cluster --cluster-name backend-cluster

  #   # Step 5: Register ECS task definition
  #   - name: Render ECS Task Definition
  #     id: task-def
  #     uses: aws-actions/amazon-ecs-render-task-definition@v1
  #     with:
  #       task-definition: ./project1/backend_rds/ecs-task-definition.json  # Path to your ECS task definition JSON file
  #       container-name: backend-rds
  #       image: 194722414339.dkr.ecr.eu-north-1.amazonaws.com/project1-backend:backend-rds

  #   # Step 6: Deploy to ECS service

  #   - name: Deploy Amazon ECS task definition
  #     uses: aws-actions/amazon-ecs-deploy-task-definition@v2
  #     with:
  #       task-definition: ${{ steps.task-def.outputs.task-definition }}
  #       service: rds-backend
  #       cluster: backend-cluster
  #       wait-for-service-stability: true


















  # deploy-ecs:
  #   runs-on: ubuntu-latest
  #   # needs: deploy-rds-backend-to-ecr
  #   steps:
  #     - name: Create cluster
  #       uses: bitovi/github-actions-deploy-ecs@v0.1.4
  #       id: ecs
  #       with:
  #         aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws_default_region: ${{ secrets.AWS_REGION }}

  #         #tf_stack_destroy: true # This is to destroy the stack
  #         tf_state_bucket_destroy: true # Will only destroy the bucket if tf_stack_destroy is true
  #         aws_ecs_enable: true
  #         aws_ecs_cluster_name: backend-cluster
  #         aws_ecs_service_name: backend-rds
  #         aws_ecs_task_name: backend_rds
  #         aws_ecs_node_count: 1
  #         aws_ecs_autoscaling_enable: true
  #         aws_ecs_autoscaling_max_nodes: 1
  #         aws_ecs_autoscaling_min_nodes: 1
  #         aws_ecs_service_launch_type: FARGATE
  #         aws_ecs_task_cpu: 1
  #         aws_ecs_task_mem: 1024
  #         aws_ecs_app_image: private.ecr.aws/project1-backend:backend-redis
  #         aws_ecs_assign_public_ip: true
  #         aws_ecs_lb_redirect_enable: true
  #         aws_ecs_lb_container_path: 'app' # Fisrt container will be the URL root path
  #         # aws_ecs_task_json_definition_file:
  #         aws_ecs_container_port: 8000
  #         aws_ecs_lb_port: 9000
  #         aws_vpc_availability_zones: a,b
