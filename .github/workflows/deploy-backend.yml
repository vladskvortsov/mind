name: Deploy VPC, EC2, RDS, ElasticCache
on: 
  workflow_dispatch:
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'project1/backend_redis/*'
  #     - 'project1/backend_rds/*'
jobs:
  deploy-ec2-rds:
    runs-on: ubuntu-latest 
    outputs:
      aws_vpc_id: ${{ steps.deploy.outputs.aws_vpc_id }}
      ec2_sg_id: ${{ steps.deploy.outputs.ec2_sg_id }}
      db_sg_id: ${{ steps.deploy.outputs.db_sg_id }}
      db_endpoint: ${{ steps.deploy.outputs.db_endpoint }}
      instance_endpoint: ${{ steps.deploy.outputs.instance_endpoint }}
    steps:
    # - id: create-user-data
    #   name: Create user data file
    #   run: |
    #       USER_DATA=$(cat <<EOF
    #       #!/bin/bash 
    #       apt update 
    #       apt install unzip
    #       curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    #       unzip awscliv2.zip
    #       ./aws/install          
    #       aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
    #       docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-rds
    #       docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-redis
    #       cd mind/
    #       docker compose up -d
    #       EOF
    #       )
    #       echo "$USER_DATA" >> ./mind/project1/user_data.sh


    # - name: Configure AWS credentials
    #   uses: aws-actions/configure-aws-credentials@v1
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-region: ${{ secrets.AWS_REGION }}

    - name: Create IAM Role
      run: |
              aws iam create-role \
              --role-name project1-ecr-access \
              --assume-role-policy-document '{
                  "Version": "2012-10-17",
                  "Statement": [
                      {
                          "Effect": "Allow",
                          "Action": [
                              "ecr:GetAuthorizationToken",
                              "ecr:BatchGetImage",
                              "ecr:GetDownloadUrlForLayer",
                              "ecr:BatchImportUpstreamImage"
                          ],
                          "Resource": "*"
                      }
                  ]
                }'
            
              aws iam create-instance-profile \
              --instance-profile-name project1-ecr-access

              aws iam add-role-to-instance-profile \
              --role-name project1-ecr-access \
              --instance-profile-name project1-ecr-access


    # - name: Attach Policy to Role
    #   run: |
        
    - id: deploy
      name: Deploy EC2 and RDS
      uses: bitovi/github-actions-deploy-docker-to-ec2@v1.0.1
      with:
        aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws_default_region: ${{ secrets.AWS_REGION }}


        ansible_start_docker_timeout: 600


        aws_vpc_create: true
        aws_vpc_name: project1-vpc
        # aws_vpc_cidr_block: 10.0.0.0/16
        aws_vpc_public_subnets: 10.10.10.0/24
        aws_vpc_private_subnets: 10.10.20.0/24
        aws_vpc_availability_zones: ${{ secrets.AWS_REGION }}a,${{ secrets.AWS_REGION }}b
        aws_elb_app_port: 8000,8003,8080
        aws_elb_listen_port: 8000,8003,80
        # aws_elb_healthcheck: "HTTP:8080"

        
        aws_ec2_instance_type: t3.micro
        aws_ec2_instance_root_vol_size: 8
        aws_ec2_port_list: 8000,8003,8080
        aws_ec2_iam_instance_profile: project1-ecr-access
        docker_repo_app_directory: ./project1/
        aws_ec2_user_data_file: ./mind/project1/user_data.sh


        # aws_rds_db_enable: true        
        # aws_rds_db_name: mydb
        # aws_rds_db_user: dbuser
        # aws_rds_db_engine: postgres
        # aws_rds_db_port: 5432
        # aws_rds_db_allocated_storage: 20
        # aws_rds_db_instance_class: db.t3.micro
        # aws_rds_db_final_snapshot:
        # aws_rds_db_multi_az: false
        # aws_rds_db_apply_immediately: true

    - name: Show results
      id: show
      run: |
          echo "${{ steps.deploy.outputs.aws_vpc_id }}"
          echo "${{ steps.deploy.outputs.ec2_sg_id }}"
          echo "${{ steps.deploy.outputs.db_endpoint }}"
          echo "${{ steps.deploy.outputs.instance_endpoint }}"

  # pull-and-run:
  #   runs-on: ubuntu-latest
  #   steps:
  #   - uses: actions/checkout@v2
  #   - uses: chris5451/aws-ecr-run-image@main
  #     with:
  #       access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #       secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #       account_id: ${{ secrets.AWS_ACCOUNT_ID }}
  #       repo: project1-backend
  #       region: ${{ secrets.AWS_REGION }}
  #       tag: backend-rds
  #       name: backend-rds
  #       port: 5432

    # - name: configure aws credentials
    #   uses: aws-actions/configure-aws-credentials@v4
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-region: ${{ secrets.AWS_REGION }}

    # - name: Deploy on EC2
    #   uses: appleboy/ssh-action@master
    #   with:
    #     host: ${{ steps.deploy.outputs.instance_endpoint }}
    #     username: ubuntu
    #     key: vladskvortsov-mind-master-ec2kp-nPMRp
    #     script: |
    #       aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
    #       docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-rds
    #       docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-redis
    #       cd mind
    #       docker compose up -d



  # deploy-elascticache:
  #   runs-on: ubuntu-latest
  #   needs: deploy-ec2-rds
  #   outputs:
  #     redis_connection_string_secret: ${{ steps.create-redis.outputs.redis_connection_string_secret }}
  #     redis_sg_id: ${{ steps.create-redis.outputs.redis_sg_id }}
  #   steps:
  #   - name: Create a Redis DB
  #     id: create-redis
  #     uses: bitovi/github-actions-deploy-redis-db@v0.1.1
  #     with:
  #       aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #       aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #       aws_default_region: ${{ secrets.AWS_REGION }}

  #       aws_redis_enable: true
  #       aws_redis_port: 6379
  #       aws_redis_multi_az_enabled: false
  #       aws_redis_apply_immediately: true
  #       aws_vpc_id: ${{ needs.deploy-ec2-rds.outputs.aws_vpc_id }}
  #       # aws_vpc_subnet_id: 
  #       aws_redis_allowed_security_groups: ${{ needs.deploy-ec2-rds.outputs.db_sg_id }}
         

        

  # deploy-backend-images:
  #   runs-on: ubuntu-latest
  #   needs: deploy-ec2-rds
  #   steps:
  #   - name: Log in to Amazon ECR
  #     uses: aws-actions/amazon-ecr-login@v1
  #     with:
  #       registry: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

  #   - name: Deploy on EC2
  #     uses: appleboy/ssh-action@master
  #     with:
  #       host: ${{ needs.deploy-ec2.outputs.instance_endpoint }}
  #       username: ubuntu
  #       key: project1-key
  #       script: |
  #         aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
  #         docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-rds
  #         docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-redis
  #         cd mind
  #         docker compose up -d




















  # deploy:
  #   runs-on: ubuntu-latest

  #   steps:
  #     - name: Configure AWS Credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: us-west-2

  #     - name: Create EC2 Launch Template
  #       run: |
  #         aws ec2 create-launch-template --launch-template-name myTemplate ...

  #     - name: Create Auto Scaling Group
  #       run: |
  #         aws autoscaling create-auto-scaling-group --auto-scaling-group-name myASG ...

  #     - name: Create Application Load Balancer
  #       run: |
  #         aws elbv2 create-load-balancer --name myALB ...

  #     - name: Create RDS Instance
  #       run: |
  #         aws rds create-db-instance --db-instance-identifier myDB ...

  #     - name: Create ElastiCache Cluster
  #       run: |
  #         aws elasticache create-cache-cluster --cluster-name myCacheCluster ...





  
  # deploy-ecs:
  #   runs-on: ubuntu-latest
  # # needs: deploy-rds-backend-to-ecr
  #   steps:
  #   - name: Create ECS Cluster
  #     run: |
  #       aws ecs create-cluster --cluster-name backend-cluster

  #   # Step 5: Register ECS task definition
  #   - name: Render ECS Task Definition
  #     id: task-def
  #     uses: aws-actions/amazon-ecs-render-task-definition@v1
  #     with:
  #       task-definition: ./project1/backend_rds/ecs-task-definition.json  # Path to your ECS task definition JSON file
  #       container-name: backend-rds
  #       image: 194722414339.dkr.ecr.eu-north-1.amazonaws.com/project1-backend:backend-rds

  #   # Step 6: Deploy to ECS service

  #   - name: Deploy Amazon ECS task definition
  #     uses: aws-actions/amazon-ecs-deploy-task-definition@v2
  #     with:
  #       task-definition: ${{ steps.task-def.outputs.task-definition }}
  #       service: rds-backend
  #       cluster: backend-cluster
  #       wait-for-service-stability: true



  # deploy-vpc:
  #   runs-on: ubuntu-latest
  #   outputs: 
  #     vpc_id: ${{ steps.create_vpc.outputs.vpc_id }}
  #     public_subnet_id: ${{ steps.create_subnets.outputs.public_subnet_id }}
  #     private_subnet_id: ${{ steps.create_subnets.outputs.private_subnet_id }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v3
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v2
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: ${{ secrets.AWS_REGION }}
          
  #     - name: Create VPC
  #       id: create_vpc
  #       run: |
  #         VPC_ID=$(aws ec2 create-vpc --cidr-block 10.0.0.0/16 --query 'Vpc.VpcId' --output text)
  #         aws ec2 modify-vpc-attribute --vpc-id $VPC_ID --enable-dns-support
  #         aws ec2 modify-vpc-attribute --vpc-id $VPC_ID --enable-dns-hostnames
  #         echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV
  #         echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT


  #     - name: Create Subnets
  #       id: create_subnets
  #       run: |
  #         PUBLIC_SUBNET_ID=$(aws ec2 create-subnet --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --cidr-block 10.0.1.0/24 --query 'Subnet.SubnetId' --output text)
  #         PRIVATE_SUBNET_ID=$(aws ec2 create-subnet --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --cidr-block 10.0.2.0/24 --query 'Subnet.SubnetId' --output text)
  #         echo "PUBLIC_SUBNET_ID=$PUBLIC_SUBNET_ID" >> $GITHUB_ENV
  #         echo "PRIVATE_SUBNET_ID=$PRIVATE_SUBNET_ID" >> $GITHUB_ENV
  #         echo "public_subnet_id=$PUBLIC_SUBNET_ID" >> $GITHUB_OUTPUT
  #         echo "private_subnet_id=$PRIVATE_SUBNET_ID" >> $GITHUB_OUTPUT

  #     - name: Create Internet Gateway and Route Table
  #       id: create_igw
  #       run: |
  #         IGW_ID=$(aws ec2 create-internet-gateway --query 'InternetGateway.InternetGatewayId' --output text)
  #         aws ec2 attach-internet-gateway --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --internet-gateway-id $IGW_ID
  #         RT_ID=$(aws ec2 create-route-table --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'RouteTable.RouteTableId' --output text)
  #         aws ec2 create-route --route-table-id $RT_ID --destination-cidr-block 0.0.0.0/0 --gateway-id $IGW_ID
  #         aws ec2 associate-route-table --subnet-id ${{ steps.create_subnets.outputs.public_subnet_id }} --route-table-id $RT_ID

  #     - name: Create Security Groups
  #       id: create_sg
  #       run: |
  #         ALB_SG_ID=$(aws ec2 create-security-group --group-name alb-sg --description "Security group for ALB" --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'GroupId' --output text)
  #         aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0
  #         aws ec2 authorize-security-group-ingress --group-id $ALB_SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
  #         ECS_SG_ID=$(aws ec2 create-security-group --group-name ecs-sg --description "Security group for ECS" --vpc-id ${{ steps.create_vpc.outputs.vpc_id }} --query 'GroupId' --output text)
  #         aws ec2 authorize-security-group-ingress --group-id $ECS_SG_ID --protocol tcp --port 80 --source-group $ALB_SG_ID
  #         echo "ecs_sg_id=$ECS_SG_ID" >> $GITHUB_OUTPUT
  #         echo "alb_sg_id=$ALB_SG_ID" >> $GITHUB_OUTPUT

  #         echo "${{ steps.create_vpc.outputs.vpc_id }}"
  #         echo "${{ steps.create_subnets.outputs.public_subnet_id }}"
  #         echo "${{ steps.create_subnets.outputs.private_subnet_id }}"