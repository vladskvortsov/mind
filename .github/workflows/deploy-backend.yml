name: Deploy VPC, EC2, RDS, ElasticCache
on: 
  workflow_dispatch:
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'project1/backend_redis/*'
  #     - 'project1/backend_rds/*'
jobs:
  deploy-rds:
    runs-on: ubuntu-latest 
    outputs:
      aws_vpc_id: ${{ steps.deploy.outputs.aws_vpc_id }}
      ec2_sg_id: ${{ steps.deploy.outputs.ec2_sg_id }}
      db_sg_id: ${{ steps.deploy.outputs.db_sg_id }}
      db_endpoint: ${{ steps.deploy.outputs.db_endpoint }}
      private_subnet_id: ${{ steps.subnets.outputs.private_subnet_id }}
      public_subnet_id: ${{ steps.subnets.outputs.public_subnet_id }}

      # instance_endpoint: ${{ steps.deploy.outputs.instance_endpoint }}

    env:  # Set secrets as environment variables for the job
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      DB_HOST: 
      REDIS_HOST: 
      CORS_ALLOWED_ORIGINS:

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Create IAM Role
      run: |
        aws iam get-role --role-name ecr-pull-role || \
        aws iam create-role --role-name ecr-pull-role \
          --assume-role-policy-document file://project1/ecr-assume-role.json

    - name: Attach ECR Permissions Policy
      run: |
        aws iam put-role-policy \
          --role-name ecr-pull-role \
          --policy-name AmazonEC2ContainerRegistryPullOnly \
          --policy-document file://project1/ecr-pull-role.json


    - name: Attach Role to the profile
      run: |
             aws iam get-instance-profile --instance-profile-name project1-ecr-access || aws iam create-instance-profile \
             --instance-profile-name project1-ecr-access


              ROLES_ATTACHED=$(aws iam get-instance-profile --instance-profile-name project1-ecr-access --query "InstanceProfile.Roles[*].RoleName" --output text)
              if [[ "$ROLES_ATTACHED" != *"$ROLE_NAME"* ]]; then
                aws iam add-role-to-instance-profile --instance-profile-name project1-ecr-access --role-name ecr-pull-role
              fi

    # - name: Check and Create SSH Key Pair if Not Exists
    #   id: create_key
    #   run: |
    #     if 
    #       aws ec2 describe-key-pairs --key-names key 2>/dev/null; then
    #       echo "Key pair 'key' already exists. Skipping creation."
    #     else
    #       aws ec2 create-key-pair --key-name key --query 'KeyMaterial' --output text > github-action-key.pem
    #       chmod 400 github-action-key.pem
    #     fi

      # env:
      #   AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #   AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Create setup.sh
      run: |
          echo "#!/bin/bash
          apt update -y
          apt install -y unzip docker.io docker-compose git awscli
          usermod -aG docker ubuntu
          systemctl restart docker
          # newgrp docker
          sudo -u ubuntu aws configure set aws_access_key_id AWS_ACCESS_KEY_ID
          sudo -u ubuntu aws configure set aws_secret_access_key AWS_SECRET_ACCESS_KEY
          sudo -u ubuntu aws ecr get-login-password --region \$AWS_REGION | docker login --username AWS --password-stdin \$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com
          cd /home/ubuntu/
          git clone https://github.com/vladskvortsov/mind.git
          cd mind/project1/
          echo \"SECRET_KEY=my-secret-key
          DEBUG=False

          DB_NAME=mydb
          DB_USER=dbuser
          # DB_PASSWORD=mypassword
          DB_HOST=$DB_HOST
          DB_PORT=5432

          REDIS_HOST=$REDIS_HOST
          REDIS_PORT=6379
          REDIS_DB=0
          #REDIS_PASSWORD=mypassword

          CORS_ALLOWED_ORIGINS=$CORS_ALLOWED_ORIGINS\" > vars.env

          echo '
          version: \"3.8\"
          services:
            backend_rds:
              env_file:
                - vars.env
              image: \$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com/project1-backend:backend-rds
              container_name: backend_rds
              ports:
                - \"8000:8000\"
              networks:
                - backend
              entrypoint: [\"sh\", \"-c\", \"sleep 10 && python manage.py runserver 0.0.0.0:8000\"]

            backend_redis:
              env_file:
                - vars.env
              image: \$AWS_ACCOUNT_ID.dkr.ecr.\$AWS_REGION.amazonaws.com/project1-backend:backend-redis
              container_name: backend_redis
              ports:
                - \"8003:8003\"
              networks:
                - backend
              entrypoint: [\"sh\", \"-c\", \"sleep 10 && python manage.py runserver 0.0.0.0:8003\"]

          networks:
            backend:
              driver: bridge' > docker-compose.yml
          
          docker-compose up -d
          " > ${{ github.workspace }}/setup.sh
          chmod 777 ${{ github.workspace }}/setup.sh
          echo "$(cat ${{ github.workspace }}/setup.sh)"



    # - id: deploy
    #   name: Deploy EC2 and RDS
    #   uses: bitovi/github-actions-deploy-docker-to-ec2@v1.0.1
    #   with:
    #     aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws_default_region: ${{ secrets.AWS_REGION }}


    #     ansible_start_docker_timeout: 600


    #     aws_vpc_create: true
    #     aws_vpc_name: project1-vpc
    #     # aws_vpc_cidr_block: 10.0.0.0/16
    #     aws_vpc_public_subnets: 10.10.10.0/24,10.10.40.0/24
    #     aws_vpc_private_subnets: 10.10.20.0/24,10.10.30.0/24
    #     aws_vpc_availability_zones:  ${{ secrets.AWS_REGION }}a,${{ secrets.AWS_REGION }}b
    #     aws_elb_create: false
    #     # aws_elb_app_port: 8000,8003,8080
    #     # aws_elb_listen_port: 8000,8003,80
    #     # # aws_elb_healthcheck: "HTTP:8080"

    #     aws_ec2_instance_create: true
    #     aws_ec2_instance_type: t3.micro
    #     aws_ec2_instance_root_vol_size: 8
    #     aws_ec2_port_list: 8000,8003,8080
    #     aws_ec2_iam_instance_profile: project1-ecr-access
    #     docker_repo_app_directory: ./project1/
    #     aws_ec2_user_data_file: ${{ github.workspace }}/setup.sh
    #     aws_ec2_create_keypair_sm: true

    #     aws_rds_db_enable: true        
    #     aws_rds_db_name: mydb
    #     aws_rds_db_user: dbuser
    #     aws_rds_db_engine: postgres
    #     aws_rds_db_port: 5432
    #     aws_rds_db_allocated_storage: 20
    #     aws_rds_db_instance_class: db.t3.micro
    #     aws_rds_db_final_snapshot:
    #     aws_rds_db_multi_az: false
    #     aws_rds_db_apply_immediately: true

# tf_stack_destroy: true
# tf_state_bucket_destroy: true

    - name: Retrieve Public and Private Subnet IDs
      id: subnets  # Step ID for accessing outputs
      run: |
        ALL_SUBNETS=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=${{ steps.deploy.outputs.aws_vpc_id }}" \
          --query "Subnets[].[SubnetId, MapPublicIpOnLaunch]" \
          --output json)

        # Separate subnets into public and private based on MapPublicIpOnLaunch
          PUBLIC_SUBNET=$(echo $ALL_SUBNETS | jq -r '.[] | select(.[1] == true) | .[0]' | head -n 1)
          PRIVATE_SUBNET=$(echo $ALL_SUBNETS | jq -r '.[] | select(.[1] == false) | .[0]' | head -n 1)

        # Store results in environment variables for use in subsequent steps
        echo "public_subnet_id=$PUBLIC_SUBNET" >> $GITHUB_OUTPUT
        echo "private_subnet_id=$PRIVATE_SUBNET" >> $GITHUB_OUTPUT

    # - name: Export ENV from AWS SecretManager
    #   uses: say8425/aws-secrets-manager-actions@v2
    #   with:
    #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
    #     SECRET_NAME: vladskvortsov-mind-master-sm-kNByk
    #     OUTPUT_PATH: 'key.env'

    - name: SM
      uses: aws-actions/aws-secretsmanager-get-secrets@v2
      with:
        secret-ids: |
          PRIVATE_KEY, vladskvortsov-mind-master-sm*
        name-transformation: uppercase
        parse-json-secrets: true

  
    - name: Export ENV from AWS SecretManager
      id: export-key
      run: |
          echo "$PRIVATE_KEY"


         

    - name: Deploy on EC2
      uses: appleboy/ssh-action@master
      with:
        host: 13.60.209.66
        username: ubuntu
        key: $VLADSKVORTSOV_MIND_MASTER_SM_KNBYK
        script: |
              cd mind/
              apt update 
              apt install -y unzip docker
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              ./aws/install 
              sudo usermod -aG docker $USER
              aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
              docker compose up -d

  deploy-elascticache:
    runs-on: ubuntu-latest
    needs: deploy-rds
    outputs:
      redis_connection_string_secret: ${{ steps.create-redis.outputs.redis_connection_string_secret }}
      redis_sg_id: ${{ steps.create-redis.outputs.redis_sg_id }}
    steps:
    - name: Create a Redis DB
      id: create-redis
      uses: bitovi/github-actions-deploy-redis-db@v0.1.1
      with:
        aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws_default_region: ${{ secrets.AWS_REGION }}

        aws_redis_enable: true
        aws_redis_port: 6379
        aws_redis_multi_az_enabled: false
        aws_redis_apply_immediately: true
        aws_vpc_id: ${{ needs.deploy-rds.outputs.aws_vpc_id }}
        aws_vpc_subnet_id: ${{ needs.deploy-rds.outputs.private_subnet_id }}
        aws_redis_allowed_security_groups: ${{ needs.deploy-rds.outputs.ec2_sg_id }}
  


  
  # deploy-ec2:
  #   runs-on: ubuntu-latest
  #   needs: 
  #    - deploy-rds
  #    - deploy-elascticache
  #   outputs:
  #     instance-id: ${{ steps.create-ec2.outputs.instance-id }}
  #   steps:
        

    # - name: Setup EC2
    #   id: create-ec2
    #   uses: truemark/aws-ec2-run-instance-action@v5
    #   with:
    #     security-group-id: ${{ needs.deploy-rds.outputs.ec2_sg_id }}
    #     subnet-id: "${{ needs.deploy-rds.outputs.public_subnet_id }}"
    #     name: project1-backend
    #     region: ${{ secrets.AWS_REGION }}
    #     image-id: "ami-08eb150f611ca277f"
    #     instance-type: "t3.micro"
    #     instance-profile: "project1-ecr-access"
    #     volume-size: 8
    #     associate-public-ip-address: true
    #     key-name: key
    #     terminate-on-post: false
    #     user-data: |
    #       #!/bin/bash
    #       apt update -y
    #       apt install -y unzip docker.io docker-compose git
    #       curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    #       unzip awscliv2.zip
    #       ./aws/install
    #       usermod -aG docker ubuntu
    #       systemctl restart docker
    #       # newgrp docker
    #       sudo -u ubuntu aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
    #       sudo -u ubuntu aws configure set aws_secret_access_key  ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #       sudo -u ubuntu aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
    #       cd /home/ubuntu/
    #       git clone https://github.com/vladskvortsov/mind.git
    #       cd mind/project1/
    #       echo "SECRET_KEY=my-secret-key
    #       DEBUG=False

    #       DB_NAME=mydb
    #       DB_USER=dbuser
    #       # DB_PASSWORD=mypassword
    #       DB_HOST=${{ needs.deploy-rds.outputs.db_endpoint }}
    #       DB_PORT=5432

    #       REDIS_HOST=${{ needs.deploy-elascticache.outputs.redis_connection_string_secret }}
    #       REDIS_PORT=6379
    #       REDIS_DB=0
    #       #REDIS_PASSWORD=mypassword

    #       CORS_ALLOWED_ORIGINS=http://d2xytvnh88jebv.cloudfront.net" > vars.env
 
    #       echo '
    #       # version: '3.8'
    #       services:
    #         backend_rds:
    #           env_file:
    #           - vars.env
    #           image: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-rds
    #           container_name: backend_rds
    #           ports:
    #             - "8000:8000"
    #           networks:
    #             - backend
    #           entrypoint: ["sh", "-c", "sleep 10 && python manage.py runserver 0.0.0.0:8000"]

    #         backend_redis:
    #           env_file:
    #           - vars.env
    #           image: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/project1-backend:backend-redis
    #           container_name: backend_redis
    #           ports:
    #             - "8003:8003"
    #           networks:
    #             - backend
    #           entrypoint: ["sh", "-c", "sleep 10 && python manage.py runserver 0.0.0.0:8003"]

    #       networks:
    #         backend:
    #           driver: bridge' > docker-compose.yml
    #       docker-compose up -d

    # - name: Attach Security Groups to EC2 Instance
    #   run: |
    #     aws ec2 modify-instance-attribute \
    #       --instance-id ${{ steps.create-ec2.outputs.instance-id }} \
    #       --groups ${{ needs.deploy-rds.outputs.db_sg_id }},${{ needs.deploy-elascticache.outputs.redis_sg_id }},${{ needs.deploy-rds.outputs.ec2_sg_id }}









    - name: Deploy on EC2
      uses: appleboy/ssh-action@master
      with:
        host: $PUBLIC_IP
        username: ubuntu
        key: $KEY
        script: |
              cd mind/
              apt update 
              apt install -y unzip docker
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              ./aws/install 
              sudo usermod -aG docker $USER
              aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
              docker compose up -d









        
